// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

export const typeDefs = /* GraphQL */ `type AggregateModule {
  count: Int!
}

type AggregateModuleConfig {
  count: Int!
}

type AggregateNavigation {
  count: Int!
}

type AggregateNavigationItem {
  count: Int!
}

type AggregatePage {
  count: Int!
}

type AggregatePrivilege {
  count: Int!
}

type AggregateRole {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type BatchPayload {
  count: Long!
}

scalar DateTime

scalar Json

scalar Long

type Module {
  id: ID!
  name: String!
  type: ModuleTypes
  configs(where: ModuleConfigWhereInput, orderBy: ModuleConfigOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ModuleConfig!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ModuleConfig {
  id: ID!
  name: String!
  type: ModuleConfigTypes
  json: Json
}

type ModuleConfigConnection {
  pageInfo: PageInfo!
  edges: [ModuleConfigEdge]!
  aggregate: AggregateModuleConfig!
}

input ModuleConfigCreateInput {
  id: ID
  name: String!
  type: ModuleConfigTypes
  json: Json
}

input ModuleConfigCreateManyInput {
  create: [ModuleConfigCreateInput!]
  connect: [ModuleConfigWhereUniqueInput!]
}

type ModuleConfigEdge {
  node: ModuleConfig!
  cursor: String!
}

enum ModuleConfigOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  type_ASC
  type_DESC
  json_ASC
  json_DESC
}

type ModuleConfigPreviousValues {
  id: ID!
  name: String!
  type: ModuleConfigTypes
  json: Json
}

input ModuleConfigScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  type: ModuleConfigTypes
  type_not: ModuleConfigTypes
  type_in: [ModuleConfigTypes!]
  type_not_in: [ModuleConfigTypes!]
  AND: [ModuleConfigScalarWhereInput!]
  OR: [ModuleConfigScalarWhereInput!]
  NOT: [ModuleConfigScalarWhereInput!]
}

type ModuleConfigSubscriptionPayload {
  mutation: MutationType!
  node: ModuleConfig
  updatedFields: [String!]
  previousValues: ModuleConfigPreviousValues
}

input ModuleConfigSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ModuleConfigWhereInput
  AND: [ModuleConfigSubscriptionWhereInput!]
  OR: [ModuleConfigSubscriptionWhereInput!]
  NOT: [ModuleConfigSubscriptionWhereInput!]
}

enum ModuleConfigTypes {
  INT
  STRING
  BOOLEAN
  DATE
  URL
  ARRAY
  JSON
}

input ModuleConfigUpdateDataInput {
  name: String
  type: ModuleConfigTypes
  json: Json
}

input ModuleConfigUpdateInput {
  name: String
  type: ModuleConfigTypes
  json: Json
}

input ModuleConfigUpdateManyDataInput {
  name: String
  type: ModuleConfigTypes
  json: Json
}

input ModuleConfigUpdateManyInput {
  create: [ModuleConfigCreateInput!]
  update: [ModuleConfigUpdateWithWhereUniqueNestedInput!]
  upsert: [ModuleConfigUpsertWithWhereUniqueNestedInput!]
  delete: [ModuleConfigWhereUniqueInput!]
  connect: [ModuleConfigWhereUniqueInput!]
  set: [ModuleConfigWhereUniqueInput!]
  disconnect: [ModuleConfigWhereUniqueInput!]
  deleteMany: [ModuleConfigScalarWhereInput!]
  updateMany: [ModuleConfigUpdateManyWithWhereNestedInput!]
}

input ModuleConfigUpdateManyMutationInput {
  name: String
  type: ModuleConfigTypes
  json: Json
}

input ModuleConfigUpdateManyWithWhereNestedInput {
  where: ModuleConfigScalarWhereInput!
  data: ModuleConfigUpdateManyDataInput!
}

input ModuleConfigUpdateWithWhereUniqueNestedInput {
  where: ModuleConfigWhereUniqueInput!
  data: ModuleConfigUpdateDataInput!
}

input ModuleConfigUpsertWithWhereUniqueNestedInput {
  where: ModuleConfigWhereUniqueInput!
  update: ModuleConfigUpdateDataInput!
  create: ModuleConfigCreateInput!
}

input ModuleConfigWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  type: ModuleConfigTypes
  type_not: ModuleConfigTypes
  type_in: [ModuleConfigTypes!]
  type_not_in: [ModuleConfigTypes!]
  AND: [ModuleConfigWhereInput!]
  OR: [ModuleConfigWhereInput!]
  NOT: [ModuleConfigWhereInput!]
}

input ModuleConfigWhereUniqueInput {
  id: ID
}

type ModuleConnection {
  pageInfo: PageInfo!
  edges: [ModuleEdge]!
  aggregate: AggregateModule!
}

input ModuleCreateInput {
  id: ID
  name: String!
  type: ModuleTypes
  configs: ModuleConfigCreateManyInput
}

input ModuleCreateManyInput {
  create: [ModuleCreateInput!]
  connect: [ModuleWhereUniqueInput!]
}

type ModuleEdge {
  node: Module!
  cursor: String!
}

enum ModuleOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  type_ASC
  type_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ModulePreviousValues {
  id: ID!
  name: String!
  type: ModuleTypes
  createdAt: DateTime!
  updatedAt: DateTime!
}

input ModuleScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  type: ModuleTypes
  type_not: ModuleTypes
  type_in: [ModuleTypes!]
  type_not_in: [ModuleTypes!]
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ModuleScalarWhereInput!]
  OR: [ModuleScalarWhereInput!]
  NOT: [ModuleScalarWhereInput!]
}

type ModuleSubscriptionPayload {
  mutation: MutationType!
  node: Module
  updatedFields: [String!]
  previousValues: ModulePreviousValues
}

input ModuleSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ModuleWhereInput
  AND: [ModuleSubscriptionWhereInput!]
  OR: [ModuleSubscriptionWhereInput!]
  NOT: [ModuleSubscriptionWhereInput!]
}

enum ModuleTypes {
  REGULAR
}

input ModuleUpdateDataInput {
  name: String
  type: ModuleTypes
  configs: ModuleConfigUpdateManyInput
}

input ModuleUpdateInput {
  name: String
  type: ModuleTypes
  configs: ModuleConfigUpdateManyInput
}

input ModuleUpdateManyDataInput {
  name: String
  type: ModuleTypes
}

input ModuleUpdateManyInput {
  create: [ModuleCreateInput!]
  update: [ModuleUpdateWithWhereUniqueNestedInput!]
  upsert: [ModuleUpsertWithWhereUniqueNestedInput!]
  delete: [ModuleWhereUniqueInput!]
  connect: [ModuleWhereUniqueInput!]
  set: [ModuleWhereUniqueInput!]
  disconnect: [ModuleWhereUniqueInput!]
  deleteMany: [ModuleScalarWhereInput!]
  updateMany: [ModuleUpdateManyWithWhereNestedInput!]
}

input ModuleUpdateManyMutationInput {
  name: String
  type: ModuleTypes
}

input ModuleUpdateManyWithWhereNestedInput {
  where: ModuleScalarWhereInput!
  data: ModuleUpdateManyDataInput!
}

input ModuleUpdateWithWhereUniqueNestedInput {
  where: ModuleWhereUniqueInput!
  data: ModuleUpdateDataInput!
}

input ModuleUpsertWithWhereUniqueNestedInput {
  where: ModuleWhereUniqueInput!
  update: ModuleUpdateDataInput!
  create: ModuleCreateInput!
}

input ModuleWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  type: ModuleTypes
  type_not: ModuleTypes
  type_in: [ModuleTypes!]
  type_not_in: [ModuleTypes!]
  configs_every: ModuleConfigWhereInput
  configs_some: ModuleConfigWhereInput
  configs_none: ModuleConfigWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ModuleWhereInput!]
  OR: [ModuleWhereInput!]
  NOT: [ModuleWhereInput!]
}

input ModuleWhereUniqueInput {
  id: ID
  name: String
}

type Mutation {
  createModule(data: ModuleCreateInput!): Module!
  updateModule(data: ModuleUpdateInput!, where: ModuleWhereUniqueInput!): Module
  updateManyModules(data: ModuleUpdateManyMutationInput!, where: ModuleWhereInput): BatchPayload!
  upsertModule(where: ModuleWhereUniqueInput!, create: ModuleCreateInput!, update: ModuleUpdateInput!): Module!
  deleteModule(where: ModuleWhereUniqueInput!): Module
  deleteManyModules(where: ModuleWhereInput): BatchPayload!
  createModuleConfig(data: ModuleConfigCreateInput!): ModuleConfig!
  updateModuleConfig(data: ModuleConfigUpdateInput!, where: ModuleConfigWhereUniqueInput!): ModuleConfig
  updateManyModuleConfigs(data: ModuleConfigUpdateManyMutationInput!, where: ModuleConfigWhereInput): BatchPayload!
  upsertModuleConfig(where: ModuleConfigWhereUniqueInput!, create: ModuleConfigCreateInput!, update: ModuleConfigUpdateInput!): ModuleConfig!
  deleteModuleConfig(where: ModuleConfigWhereUniqueInput!): ModuleConfig
  deleteManyModuleConfigs(where: ModuleConfigWhereInput): BatchPayload!
  createNavigation(data: NavigationCreateInput!): Navigation!
  updateNavigation(data: NavigationUpdateInput!, where: NavigationWhereUniqueInput!): Navigation
  updateManyNavigations(data: NavigationUpdateManyMutationInput!, where: NavigationWhereInput): BatchPayload!
  upsertNavigation(where: NavigationWhereUniqueInput!, create: NavigationCreateInput!, update: NavigationUpdateInput!): Navigation!
  deleteNavigation(where: NavigationWhereUniqueInput!): Navigation
  deleteManyNavigations(where: NavigationWhereInput): BatchPayload!
  createNavigationItem(data: NavigationItemCreateInput!): NavigationItem!
  updateNavigationItem(data: NavigationItemUpdateInput!, where: NavigationItemWhereUniqueInput!): NavigationItem
  updateManyNavigationItems(data: NavigationItemUpdateManyMutationInput!, where: NavigationItemWhereInput): BatchPayload!
  upsertNavigationItem(where: NavigationItemWhereUniqueInput!, create: NavigationItemCreateInput!, update: NavigationItemUpdateInput!): NavigationItem!
  deleteNavigationItem(where: NavigationItemWhereUniqueInput!): NavigationItem
  deleteManyNavigationItems(where: NavigationItemWhereInput): BatchPayload!
  createPage(data: PageCreateInput!): Page!
  updatePage(data: PageUpdateInput!, where: PageWhereUniqueInput!): Page
  updateManyPages(data: PageUpdateManyMutationInput!, where: PageWhereInput): BatchPayload!
  upsertPage(where: PageWhereUniqueInput!, create: PageCreateInput!, update: PageUpdateInput!): Page!
  deletePage(where: PageWhereUniqueInput!): Page
  deleteManyPages(where: PageWhereInput): BatchPayload!
  createPrivilege(data: PrivilegeCreateInput!): Privilege!
  updatePrivilege(data: PrivilegeUpdateInput!, where: PrivilegeWhereUniqueInput!): Privilege
  updateManyPrivileges(data: PrivilegeUpdateManyMutationInput!, where: PrivilegeWhereInput): BatchPayload!
  upsertPrivilege(where: PrivilegeWhereUniqueInput!, create: PrivilegeCreateInput!, update: PrivilegeUpdateInput!): Privilege!
  deletePrivilege(where: PrivilegeWhereUniqueInput!): Privilege
  deleteManyPrivileges(where: PrivilegeWhereInput): BatchPayload!
  createRole(data: RoleCreateInput!): Role!
  updateRole(data: RoleUpdateInput!, where: RoleWhereUniqueInput!): Role
  updateManyRoles(data: RoleUpdateManyMutationInput!, where: RoleWhereInput): BatchPayload!
  upsertRole(where: RoleWhereUniqueInput!, create: RoleCreateInput!, update: RoleUpdateInput!): Role!
  deleteRole(where: RoleWhereUniqueInput!): Role
  deleteManyRoles(where: RoleWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

type Navigation {
  id: ID!
  name: String!
  type: NavigationTypes
  items(where: NavigationItemWhereInput, orderBy: NavigationItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [NavigationItem!]
}

type NavigationConnection {
  pageInfo: PageInfo!
  edges: [NavigationEdge]!
  aggregate: AggregateNavigation!
}

input NavigationCreateInput {
  id: ID
  name: String!
  type: NavigationTypes
  items: NavigationItemCreateManyInput
}

input NavigationCreateManyInput {
  create: [NavigationCreateInput!]
  connect: [NavigationWhereUniqueInput!]
}

type NavigationEdge {
  node: Navigation!
  cursor: String!
}

type NavigationItem {
  id: ID!
  title: String!
  url: String
  items(where: NavigationItemWhereInput, orderBy: NavigationItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [NavigationItem!]
}

type NavigationItemConnection {
  pageInfo: PageInfo!
  edges: [NavigationItemEdge]!
  aggregate: AggregateNavigationItem!
}

input NavigationItemCreateInput {
  id: ID
  title: String!
  url: String
  items: NavigationItemCreateManyInput
}

input NavigationItemCreateManyInput {
  create: [NavigationItemCreateInput!]
  connect: [NavigationItemWhereUniqueInput!]
}

type NavigationItemEdge {
  node: NavigationItem!
  cursor: String!
}

enum NavigationItemOrderByInput {
  id_ASC
  id_DESC
  title_ASC
  title_DESC
  url_ASC
  url_DESC
}

type NavigationItemPreviousValues {
  id: ID!
  title: String!
  url: String
}

input NavigationItemScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  url: String
  url_not: String
  url_in: [String!]
  url_not_in: [String!]
  url_lt: String
  url_lte: String
  url_gt: String
  url_gte: String
  url_contains: String
  url_not_contains: String
  url_starts_with: String
  url_not_starts_with: String
  url_ends_with: String
  url_not_ends_with: String
  AND: [NavigationItemScalarWhereInput!]
  OR: [NavigationItemScalarWhereInput!]
  NOT: [NavigationItemScalarWhereInput!]
}

type NavigationItemSubscriptionPayload {
  mutation: MutationType!
  node: NavigationItem
  updatedFields: [String!]
  previousValues: NavigationItemPreviousValues
}

input NavigationItemSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: NavigationItemWhereInput
  AND: [NavigationItemSubscriptionWhereInput!]
  OR: [NavigationItemSubscriptionWhereInput!]
  NOT: [NavigationItemSubscriptionWhereInput!]
}

input NavigationItemUpdateDataInput {
  title: String
  url: String
  items: NavigationItemUpdateManyInput
}

input NavigationItemUpdateInput {
  title: String
  url: String
  items: NavigationItemUpdateManyInput
}

input NavigationItemUpdateManyDataInput {
  title: String
  url: String
}

input NavigationItemUpdateManyInput {
  create: [NavigationItemCreateInput!]
  update: [NavigationItemUpdateWithWhereUniqueNestedInput!]
  upsert: [NavigationItemUpsertWithWhereUniqueNestedInput!]
  delete: [NavigationItemWhereUniqueInput!]
  connect: [NavigationItemWhereUniqueInput!]
  set: [NavigationItemWhereUniqueInput!]
  disconnect: [NavigationItemWhereUniqueInput!]
  deleteMany: [NavigationItemScalarWhereInput!]
  updateMany: [NavigationItemUpdateManyWithWhereNestedInput!]
}

input NavigationItemUpdateManyMutationInput {
  title: String
  url: String
}

input NavigationItemUpdateManyWithWhereNestedInput {
  where: NavigationItemScalarWhereInput!
  data: NavigationItemUpdateManyDataInput!
}

input NavigationItemUpdateWithWhereUniqueNestedInput {
  where: NavigationItemWhereUniqueInput!
  data: NavigationItemUpdateDataInput!
}

input NavigationItemUpsertWithWhereUniqueNestedInput {
  where: NavigationItemWhereUniqueInput!
  update: NavigationItemUpdateDataInput!
  create: NavigationItemCreateInput!
}

input NavigationItemWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  url: String
  url_not: String
  url_in: [String!]
  url_not_in: [String!]
  url_lt: String
  url_lte: String
  url_gt: String
  url_gte: String
  url_contains: String
  url_not_contains: String
  url_starts_with: String
  url_not_starts_with: String
  url_ends_with: String
  url_not_ends_with: String
  items_every: NavigationItemWhereInput
  items_some: NavigationItemWhereInput
  items_none: NavigationItemWhereInput
  AND: [NavigationItemWhereInput!]
  OR: [NavigationItemWhereInput!]
  NOT: [NavigationItemWhereInput!]
}

input NavigationItemWhereUniqueInput {
  id: ID
}

enum NavigationOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  type_ASC
  type_DESC
}

type NavigationPreviousValues {
  id: ID!
  name: String!
  type: NavigationTypes
}

input NavigationScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  type: NavigationTypes
  type_not: NavigationTypes
  type_in: [NavigationTypes!]
  type_not_in: [NavigationTypes!]
  AND: [NavigationScalarWhereInput!]
  OR: [NavigationScalarWhereInput!]
  NOT: [NavigationScalarWhereInput!]
}

type NavigationSubscriptionPayload {
  mutation: MutationType!
  node: Navigation
  updatedFields: [String!]
  previousValues: NavigationPreviousValues
}

input NavigationSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: NavigationWhereInput
  AND: [NavigationSubscriptionWhereInput!]
  OR: [NavigationSubscriptionWhereInput!]
  NOT: [NavigationSubscriptionWhereInput!]
}

enum NavigationTypes {
  TOP
  BOTTOM
}

input NavigationUpdateDataInput {
  name: String
  type: NavigationTypes
  items: NavigationItemUpdateManyInput
}

input NavigationUpdateInput {
  name: String
  type: NavigationTypes
  items: NavigationItemUpdateManyInput
}

input NavigationUpdateManyDataInput {
  name: String
  type: NavigationTypes
}

input NavigationUpdateManyInput {
  create: [NavigationCreateInput!]
  update: [NavigationUpdateWithWhereUniqueNestedInput!]
  upsert: [NavigationUpsertWithWhereUniqueNestedInput!]
  delete: [NavigationWhereUniqueInput!]
  connect: [NavigationWhereUniqueInput!]
  set: [NavigationWhereUniqueInput!]
  disconnect: [NavigationWhereUniqueInput!]
  deleteMany: [NavigationScalarWhereInput!]
  updateMany: [NavigationUpdateManyWithWhereNestedInput!]
}

input NavigationUpdateManyMutationInput {
  name: String
  type: NavigationTypes
}

input NavigationUpdateManyWithWhereNestedInput {
  where: NavigationScalarWhereInput!
  data: NavigationUpdateManyDataInput!
}

input NavigationUpdateWithWhereUniqueNestedInput {
  where: NavigationWhereUniqueInput!
  data: NavigationUpdateDataInput!
}

input NavigationUpsertWithWhereUniqueNestedInput {
  where: NavigationWhereUniqueInput!
  update: NavigationUpdateDataInput!
  create: NavigationCreateInput!
}

input NavigationWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  type: NavigationTypes
  type_not: NavigationTypes
  type_in: [NavigationTypes!]
  type_not_in: [NavigationTypes!]
  items_every: NavigationItemWhereInput
  items_some: NavigationItemWhereInput
  items_none: NavigationItemWhereInput
  AND: [NavigationWhereInput!]
  OR: [NavigationWhereInput!]
  NOT: [NavigationWhereInput!]
}

input NavigationWhereUniqueInput {
  id: ID
}

interface Node {
  id: ID!
}

type Page {
  id: ID!
  type: PageTypes
  title: String!
  description: String
  content(where: ModuleWhereInput, orderBy: ModuleOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Module!]
  navigations(where: NavigationWhereInput, orderBy: NavigationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Navigation!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PageConnection {
  pageInfo: PageInfo!
  edges: [PageEdge]!
  aggregate: AggregatePage!
}

input PageCreateInput {
  id: ID
  type: PageTypes
  title: String!
  description: String
  content: ModuleCreateManyInput
  navigations: NavigationCreateManyInput
}

type PageEdge {
  node: Page!
  cursor: String!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

enum PageOrderByInput {
  id_ASC
  id_DESC
  type_ASC
  type_DESC
  title_ASC
  title_DESC
  description_ASC
  description_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type PagePreviousValues {
  id: ID!
  type: PageTypes
  title: String!
  description: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PageSubscriptionPayload {
  mutation: MutationType!
  node: Page
  updatedFields: [String!]
  previousValues: PagePreviousValues
}

input PageSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PageWhereInput
  AND: [PageSubscriptionWhereInput!]
  OR: [PageSubscriptionWhereInput!]
  NOT: [PageSubscriptionWhereInput!]
}

enum PageTypes {
  REGULAR
}

input PageUpdateInput {
  type: PageTypes
  title: String
  description: String
  content: ModuleUpdateManyInput
  navigations: NavigationUpdateManyInput
}

input PageUpdateManyMutationInput {
  type: PageTypes
  title: String
  description: String
}

input PageWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  type: PageTypes
  type_not: PageTypes
  type_in: [PageTypes!]
  type_not_in: [PageTypes!]
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  content_every: ModuleWhereInput
  content_some: ModuleWhereInput
  content_none: ModuleWhereInput
  navigations_every: NavigationWhereInput
  navigations_some: NavigationWhereInput
  navigations_none: NavigationWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [PageWhereInput!]
  OR: [PageWhereInput!]
  NOT: [PageWhereInput!]
}

input PageWhereUniqueInput {
  id: ID
}

type Privilege {
  id: ID!
  name: String!
  type: PrivilegeTypes!
  payload: Json
  description: String
}

type PrivilegeConnection {
  pageInfo: PageInfo!
  edges: [PrivilegeEdge]!
  aggregate: AggregatePrivilege!
}

input PrivilegeCreateInput {
  id: ID
  name: String!
  type: PrivilegeTypes!
  payload: Json
  description: String
}

input PrivilegeCreateManyInput {
  create: [PrivilegeCreateInput!]
  connect: [PrivilegeWhereUniqueInput!]
}

type PrivilegeEdge {
  node: Privilege!
  cursor: String!
}

enum PrivilegeOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  type_ASC
  type_DESC
  payload_ASC
  payload_DESC
  description_ASC
  description_DESC
}

type PrivilegePreviousValues {
  id: ID!
  name: String!
  type: PrivilegeTypes!
  payload: Json
  description: String
}

input PrivilegeScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  type: PrivilegeTypes
  type_not: PrivilegeTypes
  type_in: [PrivilegeTypes!]
  type_not_in: [PrivilegeTypes!]
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  AND: [PrivilegeScalarWhereInput!]
  OR: [PrivilegeScalarWhereInput!]
  NOT: [PrivilegeScalarWhereInput!]
}

type PrivilegeSubscriptionPayload {
  mutation: MutationType!
  node: Privilege
  updatedFields: [String!]
  previousValues: PrivilegePreviousValues
}

input PrivilegeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PrivilegeWhereInput
  AND: [PrivilegeSubscriptionWhereInput!]
  OR: [PrivilegeSubscriptionWhereInput!]
  NOT: [PrivilegeSubscriptionWhereInput!]
}

enum PrivilegeTypes {
  CAN_READ_PAGES
}

input PrivilegeUpdateDataInput {
  name: String
  type: PrivilegeTypes
  payload: Json
  description: String
}

input PrivilegeUpdateInput {
  name: String
  type: PrivilegeTypes
  payload: Json
  description: String
}

input PrivilegeUpdateManyDataInput {
  name: String
  type: PrivilegeTypes
  payload: Json
  description: String
}

input PrivilegeUpdateManyInput {
  create: [PrivilegeCreateInput!]
  update: [PrivilegeUpdateWithWhereUniqueNestedInput!]
  upsert: [PrivilegeUpsertWithWhereUniqueNestedInput!]
  delete: [PrivilegeWhereUniqueInput!]
  connect: [PrivilegeWhereUniqueInput!]
  set: [PrivilegeWhereUniqueInput!]
  disconnect: [PrivilegeWhereUniqueInput!]
  deleteMany: [PrivilegeScalarWhereInput!]
  updateMany: [PrivilegeUpdateManyWithWhereNestedInput!]
}

input PrivilegeUpdateManyMutationInput {
  name: String
  type: PrivilegeTypes
  payload: Json
  description: String
}

input PrivilegeUpdateManyWithWhereNestedInput {
  where: PrivilegeScalarWhereInput!
  data: PrivilegeUpdateManyDataInput!
}

input PrivilegeUpdateWithWhereUniqueNestedInput {
  where: PrivilegeWhereUniqueInput!
  data: PrivilegeUpdateDataInput!
}

input PrivilegeUpsertWithWhereUniqueNestedInput {
  where: PrivilegeWhereUniqueInput!
  update: PrivilegeUpdateDataInput!
  create: PrivilegeCreateInput!
}

input PrivilegeWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  type: PrivilegeTypes
  type_not: PrivilegeTypes
  type_in: [PrivilegeTypes!]
  type_not_in: [PrivilegeTypes!]
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  AND: [PrivilegeWhereInput!]
  OR: [PrivilegeWhereInput!]
  NOT: [PrivilegeWhereInput!]
}

input PrivilegeWhereUniqueInput {
  id: ID
}

type Query {
  module(where: ModuleWhereUniqueInput!): Module
  modules(where: ModuleWhereInput, orderBy: ModuleOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Module]!
  modulesConnection(where: ModuleWhereInput, orderBy: ModuleOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ModuleConnection!
  moduleConfig(where: ModuleConfigWhereUniqueInput!): ModuleConfig
  moduleConfigs(where: ModuleConfigWhereInput, orderBy: ModuleConfigOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ModuleConfig]!
  moduleConfigsConnection(where: ModuleConfigWhereInput, orderBy: ModuleConfigOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ModuleConfigConnection!
  navigation(where: NavigationWhereUniqueInput!): Navigation
  navigations(where: NavigationWhereInput, orderBy: NavigationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Navigation]!
  navigationsConnection(where: NavigationWhereInput, orderBy: NavigationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): NavigationConnection!
  navigationItem(where: NavigationItemWhereUniqueInput!): NavigationItem
  navigationItems(where: NavigationItemWhereInput, orderBy: NavigationItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [NavigationItem]!
  navigationItemsConnection(where: NavigationItemWhereInput, orderBy: NavigationItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): NavigationItemConnection!
  page(where: PageWhereUniqueInput!): Page
  pages(where: PageWhereInput, orderBy: PageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Page]!
  pagesConnection(where: PageWhereInput, orderBy: PageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PageConnection!
  privilege(where: PrivilegeWhereUniqueInput!): Privilege
  privileges(where: PrivilegeWhereInput, orderBy: PrivilegeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Privilege]!
  privilegesConnection(where: PrivilegeWhereInput, orderBy: PrivilegeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PrivilegeConnection!
  role(where: RoleWhereUniqueInput!): Role
  roles(where: RoleWhereInput, orderBy: RoleOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Role]!
  rolesConnection(where: RoleWhereInput, orderBy: RoleOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): RoleConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

type Role {
  id: ID!
  name: String
  type: RolesType
  description: String
  privileges(where: PrivilegeWhereInput, orderBy: PrivilegeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Privilege!]
}

type RoleConnection {
  pageInfo: PageInfo!
  edges: [RoleEdge]!
  aggregate: AggregateRole!
}

input RoleCreateInput {
  id: ID
  name: String
  type: RolesType
  description: String
  privileges: PrivilegeCreateManyInput
}

input RoleCreateOneInput {
  create: RoleCreateInput
  connect: RoleWhereUniqueInput
}

type RoleEdge {
  node: Role!
  cursor: String!
}

enum RoleOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  type_ASC
  type_DESC
  description_ASC
  description_DESC
}

type RolePreviousValues {
  id: ID!
  name: String
  type: RolesType
  description: String
}

enum RolesType {
  ADMIN
  USER
}

type RoleSubscriptionPayload {
  mutation: MutationType!
  node: Role
  updatedFields: [String!]
  previousValues: RolePreviousValues
}

input RoleSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: RoleWhereInput
  AND: [RoleSubscriptionWhereInput!]
  OR: [RoleSubscriptionWhereInput!]
  NOT: [RoleSubscriptionWhereInput!]
}

input RoleUpdateDataInput {
  name: String
  type: RolesType
  description: String
  privileges: PrivilegeUpdateManyInput
}

input RoleUpdateInput {
  name: String
  type: RolesType
  description: String
  privileges: PrivilegeUpdateManyInput
}

input RoleUpdateManyMutationInput {
  name: String
  type: RolesType
  description: String
}

input RoleUpdateOneRequiredInput {
  create: RoleCreateInput
  update: RoleUpdateDataInput
  upsert: RoleUpsertNestedInput
  connect: RoleWhereUniqueInput
}

input RoleUpsertNestedInput {
  update: RoleUpdateDataInput!
  create: RoleCreateInput!
}

input RoleWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  type: RolesType
  type_not: RolesType
  type_in: [RolesType!]
  type_not_in: [RolesType!]
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  privileges_every: PrivilegeWhereInput
  privileges_some: PrivilegeWhereInput
  privileges_none: PrivilegeWhereInput
  AND: [RoleWhereInput!]
  OR: [RoleWhereInput!]
  NOT: [RoleWhereInput!]
}

input RoleWhereUniqueInput {
  id: ID
  name: String
}

type Subscription {
  module(where: ModuleSubscriptionWhereInput): ModuleSubscriptionPayload
  moduleConfig(where: ModuleConfigSubscriptionWhereInput): ModuleConfigSubscriptionPayload
  navigation(where: NavigationSubscriptionWhereInput): NavigationSubscriptionPayload
  navigationItem(where: NavigationItemSubscriptionWhereInput): NavigationItemSubscriptionPayload
  page(where: PageSubscriptionWhereInput): PageSubscriptionPayload
  privilege(where: PrivilegeSubscriptionWhereInput): PrivilegeSubscriptionPayload
  role(where: RoleSubscriptionWhereInput): RoleSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type User {
  id: ID!
  email: String!
  name: String!
  role: Role!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  email: String!
  name: String!
  role: RoleCreateOneInput!
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  email_ASC
  email_DESC
  name_ASC
  name_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type UserPreviousValues {
  id: ID!
  email: String!
  name: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateInput {
  email: String
  name: String
  role: RoleUpdateOneRequiredInput
}

input UserUpdateManyMutationInput {
  email: String
  name: String
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  role: RoleWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  email: String
}
`